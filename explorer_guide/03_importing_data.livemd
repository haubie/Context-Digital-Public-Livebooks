<!-- livebook:{"persist_outputs":true} -->

# Explorer: 2 - Importing data

```elixir
Mix.install([{:explorer, "~> 0.9.2"}, {:kino_vega_lite, "~> 0.1.11"}])
```

## Set the alias

As mentioned in **2 - Getting Started**, yo make our code a bit more concise, we can create a shorter 'DF' alias for the Explorer.DataFrame module. `require` will load Explorer's macro features which make for a friendly way to query dataframes.

```elixir
require Explorer.DataFrame, as: DF
```

<!-- livebook:{"output":true} -->

```
Explorer.DataFrame
```

## From CSV and TSV files

Let's import the Tiantic dataset from https://github.com/datasciencedojo

```elixir
titanic_dataset_csv = "https://raw.githubusercontent.com/datasciencedojo/datasets/refs/heads/master/titanic.csv"
df = DF.from_csv!(titanic_dataset_csv)
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[891 x 12]
  PassengerId s64 [1, 2, 3, 4, 5, ...]
  Survived s64 [0, 1, 1, 1, 0, ...]
  Pclass s64 [3, 1, 3, 1, 3, ...]
  Name string ["Braund, Mr. Owen Harris", "Cumings, Mrs. John Bradley (Florence Briggs Thayer)",
   "Heikkinen, Miss. Laina", "Futrelle, Mrs. Jacques Heath (Lily May Peel)",
   "Allen, Mr. William Henry", ...]
  Sex string ["male", "female", "female", "female", "male", ...]
  Age f64 [22.0, 38.0, 26.0, 35.0, 35.0, ...]
  SibSp s64 [1, 1, 0, 1, 0, ...]
  Parch s64 [0, 0, 0, 0, 0, ...]
  Ticket string ["A/5 21171", "PC 17599", "STON/O2. 3101282", "113803", "373450", ...]
  Fare f64 [7.25, 71.2833, 7.925, 53.1, 8.05, ...]
  Cabin string [nil, "C85", nil, "C123", nil, ...]
  Embarked string ["S", "C", "S", "S", "S", ...]
>
```

```elixir
DF.to_csv!(df, "titanic.csv")
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
DF.to_parquet!(df, "titanic.parquet")
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
DF.to_ipc!(df, "titanic.arrow")
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
DF.to_ndjson!(df, "titanic.ndjson")
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
DF.to_ipc_stream!(df, "titanic.arrows")
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
File.cwd!()
```

<!-- livebook:{"output":true} -->

```
"/Users/haubie"
```

```elixir

```

This tells us that there are 891 rows and 12 columns.

Explorer does a good job of determining `nil` values. But you provide a list of values to be interpreted as `nil` during import with the `:nil_values` option:

```elixir
df = DF.from_csv!(titanic_dataset_csv, nil_values: [""])
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[891 x 12]
  PassengerId s64 [1, 2, 3, 4, 5, ...]
  Survived s64 [0, 1, 1, 1, 0, ...]
  Pclass s64 [3, 1, 3, 1, 3, ...]
  Name string ["Braund, Mr. Owen Harris", "Cumings, Mrs. John Bradley (Florence Briggs Thayer)",
   "Heikkinen, Miss. Laina", "Futrelle, Mrs. Jacques Heath (Lily May Peel)",
   "Allen, Mr. William Henry", ...]
  Sex string ["male", "female", "female", "female", "male", ...]
  Age f64 [22.0, 38.0, 26.0, 35.0, 35.0, ...]
  SibSp s64 [1, 1, 0, 1, 0, ...]
  Parch s64 [0, 0, 0, 0, 0, ...]
  Ticket string ["A/5 21171", "PC 17599", "STON/O2. 3101282", "113803", "373450", ...]
  Fare f64 [7.25, 71.2833, 7.925, 53.1, 8.05, ...]
  Cabin string [nil, "C85", nil, "C123", nil, ...]
  Embarked string ["S", "C", "S", "S", "S", ...]
>
```

Columns can be selected by it's index number, for example to get column 0 and 1:

```elixir
df = DF.from_csv!(titanic_dataset_csv, columns: [0, 1])
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[891 x 2]
  PassengerId s64 [1, 2, 3, 4, 5, ...]
  Survived s64 [0, 1, 1, 1, 0, ...]
>
```

Alternatively, the name of the column(s) you want to fetch can be specified:

```elixir
df = DF.from_csv!(titanic_dataset_csv, columns: [:PassengerId, :Survived])
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[891 x 2]
  PassengerId s64 [1, 2, 3, 4, 5, ...]
  Survived s64 [0, 1, 1, 1, 0, ...]
>
```

```elixir
df = DF.from_csv!(titanic_dataset_csv, skip_rows: 100)
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[791 x 12]
  100 s64 [101, 102, 103, 104, 105, ...]
  0 s64 [0, 0, 0, 0, 0, ...]
  2 s64 [3, 3, 1, 3, 3, ...]
  Kantor, Mr. Sinai string ["Petranec, Miss. Matilda", "Petroff, Mr. Pastcho (\"Pentcho\")",
   "White, Mr. Richard Frasar", "Johansson, Mr. Gustaf Joel", "Gustafsson, Mr. Anders Vilhelm", ...]
  male string ["female", "male", "male", "male", "male", ...]
  34 f64 [28.0, nil, 21.0, 33.0, 37.0, ...]
  1 s64 [0, 0, 0, 0, 2, ...]
  0_duplicated_0 s64 [0, 0, 1, 0, 0, ...]
  244367 string ["349245", "349215", "35281", "7540", "3101276", ...]
  26 f64 [7.8958, 7.8958, 77.2875, 8.6542, 7.925, ...]
   string [nil, nil, "D26", nil, nil, ...]
  S string ["S", "S", "S", "S", "S", ...]
>
```

## From Parquet

Hugging Face have public datasets available at: https://huggingface.co/datasets/ which as stored as Parquet files.

Let's try and load [Dad jokes](https://huggingface.co/datasets/shuttie/dadjokes) directly from Hugging Face.

The direct link to the Parquet file is at: https://huggingface.co/api/datasets/shuttie/dadjokes/parquet/default/train/0.parquet

```elixir
jokes_parquet_url = "https://huggingface.co/api/datasets/shuttie/dadjokes/parquet/default/train/0.parquet"
df = DF.from_parquet!(jokes_parquet_url)
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[52000 x 2]
  question string ["I asked my priest how he gets holy water",
   "Life Hack: If you play My Chemical Romance loud enough in your yard",
   "OMG. SISTERS. JAMES. CHARLES. IS. DOING. A", "Why did Mr.  Potato Head get pulled over",
   "On zombie cravings.  My kids and i had some fun with these on a car trip this past weekend.   What do zombie plumbers crave.  Draaaaains.   What do zombie pilots crave.  Planes.  Plaaaanes.   What do zombie conductors crave.  Traaaains.   What do zombie opthalmologists crave.  Fraaames.   What do zombie construction workers crave.  Craaanes.   What do zombie nurses crave.  Paaains.   What do vampires crave",
   ...]
  response string ["He said itâ€™s just regular water, he just boils the hell out of it",
   "your grass will cut itself", "GIVEAWAY his career", "He was baked", "Blood", ...]
>
```

You can see there are 52,000 rows of data, and 2 columns, one for the `question` and one for the `response` both of type string.

### Random joke

So we can get familiar with, lets see if we can pick a random joke. Explorer has a `shuffle` function which will change the order of the rows of a dataframe randomly. Then let's pick the first one off the top using the `head` function:

```elixir
DF.shuffle(df) |> DF.head(1)
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[1 x 2]
  question string ["My dad has a rare genetic disorder that he passed down to me.  He poops his pants every hour on the hour"]
  response string ["Needles to say I have really shitty genes"]
>
```

## From JSON

```elixir
json_file = "https://storage.googleapis.com/tinybird-assets/datasets/guides/how-to-ingest-ndjson-data/events_100k.ndjson"
df = DF.from_ndjson!(json_file)
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[100000 x 5]
  date string ["2020-06-13 22:07:41", "2015-12-17 17:30:32", "2017-05-02 10:38:35",
   "2019-06-05 12:55:52", "2016-07-03 17:57:33", ...]
  product_id string ["67d3e582-1aaa-11eb-bdb8-acde48001122", "6bf7c3f4-1aaa-11eb-8c4f-acde48001122",
   "6700ac76-1aaa-11eb-92f9-acde48001122", "6aab26a8-1aaa-11eb-ac17-acde48001122",
   "62a05d18-1aaa-11eb-b7a3-acde48001122", ...]
  user_id s64 [521963, 897297, 814508, 148376, 578997, ...]
  event string ["remove_item_from_cart", "add_item_to_cart", "add_item_to_cart", "buy", "view", ...]
  extra_data struct[3] [
    %{"city" => "Albany", "price" => nil, "term" => nil},
    %{"city" => "Columbia", "price" => nil, "term" => nil},
    %{"city" => "Atlanta", "price" => nil, ...},
    %{"city" => "Harrisburg", ...},
    %{...},
    ...
  ]
>
```

## From IPC

```elixir

```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[0 x 0]
>
```

## From database

```elixir

```

## From Elixir data structure

```elixir
elixir_map = %{
  dataframes: ["Explorer", "Pandas", "", "Polars"],
  language: ["Elixir", "Python", "", "Rust"]
}

DF.new(elixir_map)
```

<!-- livebook:{"output":true} -->

```
#Explorer.DataFrame<
  Polars[4 x 2]
  language string ["Elixir", "Python", "", "Rust"]
  dataframes string ["Explorer", "Pandas", "", "Polars"]
>
```
